#!/usr/bin/env python3
"""Python port of the ``jpatch`` binary from JojoDiff.

Reads a patch generated by either the C++ ``jdiff`` program or the
Python ``jdiff.py`` script in the same directory and reconstructs the
"new" file from an original file.

Usage::

    python3 jpatch.py oldfile patchfile [outputfile]

If ``outputfile`` is omitted the data is written to stdout.

"""

import argparse
import sys

# operation codes (must match the values in JOutBin.cpp / jpatch.cpp)
ESC = 0xA7
MOD = 0xA6
INS = 0xA5
DEL = 0xA4
EQL = 0xA3
BKT = 0xA2


# size of copy buffer when moving bytes from the original file
eql_bufsz = 4096


def read_len(fobj):
    """Read a length value from the patch stream."""
    b = fobj.read(1)
    if not b:
        raise EOFError
    v = b[0]
    if v < 252:
        return v + 1
    elif v == 252:
        xb = fobj.read(1)
        if not xb:
            raise EOFError
        return 253 + xb[0]
    elif v == 253:
        hi = fobj.read(1)
        lo = fobj.read(1)
        if not hi or not lo:
            raise EOFError
        return (hi[0] << 8) + lo[0]
    elif v == 254:
        data = fobj.read(4)
        if len(data) < 4:
            raise EOFError
        return int.from_bytes(data, "big")
    else:
        # 255 -> 64 bit
        data = fobj.read(8)
        if len(data) < 8:
            raise EOFError
        return int.from_bytes(data, "big")


def apply_patch(orig_stream, patch_stream, out_stream, verbose=0):
    """Core patching logic translated from jpatch.cpp."""
    liOpr = ESC
    lzMod = 0
    lbChg = False
    lbEsc = False

    while True:
        byte = patch_stream.read(1)
        if not byte:
            break
        liInp = byte[0]

        # operator parsing - if we see an escape, the following byte
        # may change the current operation and/or consume extra length
        # bytes.  Note that we *do not* skip the remainder of the loop
        # because the byte that triggered the change may itself be
        # meaningful when processed under the new operation.
        if liInp == ESC:
            nxt = patch_stream.read(1)
            if not nxt:
                break
            kind = nxt[0]
            if kind == MOD:
                liOpr = MOD
                lbChg = True
            elif kind == INS:
                liOpr = INS
                lbChg = True
            elif kind == DEL:
                liOpr = DEL
                lzOff = read_len(patch_stream)
                if verbose >= 1:
                    print(f"DEL {lzOff}")
                orig_stream.seek(lzOff + lzMod, 1)
                lzMod = 0
                lbChg = True
            elif kind == EQL:
                liOpr = EQL
                lzOff = read_len(patch_stream)
                if lzMod > 0:
                    orig_stream.seek(lzMod, 1)
                    lzMod = 0
                # copy equal bytes from original to output
                remaining = lzOff
                while remaining > 0:
                    chunk = orig_stream.read(min(eql_bufsz, remaining))
                    if not chunk:
                        raise IOError("unexpected EOF on original file")
                    out_stream.write(chunk)
                    remaining -= len(chunk)
                lbChg = True
            elif kind == BKT:
                liOpr = BKT
                lzOff = read_len(patch_stream)
                orig_stream.seek(lzMod - lzOff, 1)
                lzMod = 0
                lbChg = True
            elif kind == ESC:
                # escaped ESC in data, will be handled below
                if verbose > 2:
                    print("ESC ESC (data)")
            else:
                # unknown escape, treat as literal after marking
                lbEsc = True
            # deliberately no continue: fall through to allow the
            # byte following the escape to be processed by the
            # switch below if appropriate.

        # data handling when previous sequence is not a change marker
        if lbChg:
            lbChg = False
        else:
            if liOpr == MOD:
                if lbEsc:
                    out_stream.write(bytes([ESC]))
                    lzMod += 1
                out_stream.write(bytes([liInp]))
                lzMod += 1
            elif liOpr == INS:
                if lbEsc:
                    out_stream.write(bytes([ESC]))
                out_stream.write(bytes([liInp]))
            # DEL/EQL/BKT do nothing here
        lbEsc = False


def main():
    parser = argparse.ArgumentParser(description="Apply a JojoDiff patch")
    parser.add_argument("original", help="path to original file")
    parser.add_argument("patch", help="path to patch file")
    parser.add_argument(
        "output",
        nargs="?",
        help="output filename (default stdout)",
        default="-",
    )
    parser.add_argument("-v", action="count", default=0, help="increase verbosity")
    args = parser.parse_args()

    if args.original == "-":
        orig = sys.stdin.buffer
    else:
        orig = open(args.original, "rb")
    if args.patch == "-":
        pat = sys.stdin.buffer
    else:
        pat = open(args.patch, "rb")
    if args.output == "-":
        out = sys.stdout.buffer
    else:
        out = open(args.output, "wb")

    try:
        apply_patch(orig, pat, out, verbose=args.v)
    finally:
        if orig is not sys.stdin.buffer:
            orig.close()
        if pat is not sys.stdin.buffer:
            pat.close()
        if out is not sys.stdout.buffer:
            out.close()


if __name__ == "__main__":
    main()
